---

---

# Visualizações dos municípios brasileiros nas eleições de 2024

Criei esse notebook para ser um projetinho de visualização geográfica do primeiro turno das eleições municipais de 2024, buscando também incluir dados comparativos de população nos dados geográficos.

## Carregar dados de partidos políticos e das eleições

Os dados de afinidade política vem da análise do grupo de dados da Folha de S. Paulo, a DeltaFolha. O repositório está [neste link](https://github.com/deltafolha/proximidade-partidaria-2024/tree/main).

```{r}
library(tidyverse)
library(geobr)
library(sf)

afinidade <- read_csv("data/afinidade_ideologica.csv")
glimpse(afinidade)
```
Mutar os tipos de dados das colunas para ficar mais fácil a visualização futura:

```{r}
afinidade <- afinidade |>
  mutate(
    partido = as.factor(partido),
    label = as.factor(label)
  )
```

Os dados das eleições vieram do [próprio site do TSE](https://dadosabertos.tse.jus.br/dataset/resultados-2024).

```{r}
df_all <- read_delim(
  "data/votacao_partido_munzona_2024_BRASIL.csv", 
  delim = ";", locale = locale(encoding = "latin1")
)
glimpse(df_all)
```

Pipeline para pegar os dados dos prefeitos vencedores por município:

```{r}
df_prefeitos <- df_all |>
  filter(DS_CARGO == "Prefeito") |>
  mutate(
    uf = as.factor(SG_UF),
    partido = as.factor(SG_PARTIDO),
    id_municipio_tse = as.integer(CD_MUNICIPIO),
    QT_VOTOS_NOMINAIS_VALIDOS = as.integer(QT_VOTOS_NOMINAIS_VALIDOS),
    QT_VOTOS_NOMINAIS_ANUL_SUBJUD = as.integer(QT_VOTOS_NOMINAIS_ANUL_SUBJUD),
  ) |>
  group_by(NM_MUNICIPIO, uf, partido, id_municipio_tse) |>
  summarise(
    votos_nominais_validos = sum(QT_VOTOS_NOMINAIS_VALIDOS),
    votos_nominais_anul = sum(QT_VOTOS_NOMINAIS_ANUL_SUBJUD),
  ) |>
  group_by(NM_MUNICIPIO, uf) |>
  filter(dense_rank(desc(votos_nominais_validos)) == 1) # pegar o vencedor
```

Checando por empates:

```{r}
df_prefeitos |>
  count(NM_MUNICIPIO, uf, id_municipio_tse) |>
  arrange(desc(n))
```

Inhaúma teve um empate, [com o candidato do Republicanos ganhando pelo critério da idade](https://g1.globo.com/mg/minas-gerais/eleicoes/2024/noticia/2024/10/06/eleicao-em-inhauma-mg-termina-empatada-em-2434-x-2434-votos-entenda-como-vencedor-e-escolhido.ghtml).

```{r}
df_prefeitos <- df_prefeitos |> filter(id_municipio_tse != 46191 | partido == "REPUBLICANOS")
```

Carregar relação IBGE-TSE:

```{r}
df_ibge_tse <- read_csv("data/codigo_ibge_tse.csv")

df_ibge_tse <- df_ibge_tse |>
  mutate(
    id_municipio = as.integer(id_municipio),
    id_municipio_tse = as.integer(id_municipio_tse),
  )
glimpse(df_ibge_tse)
```

Checar nulos:

```{r}
df_prefeitos |>
  left_join(df_ibge_tse, by = join_by(id_municipio_tse)) |>
  filter(is.na(id_municipio))
```

[Boa Esperança do Norte é um município novo](https://g1.globo.com/mt/mato-grosso/noticia/2023/10/13/conheca-boa-esperanca-do-norte-e-saiba-o-que-tem-no-novo-municipio-de-mt.ghtml) que não deve ter entrado na base do IBGE. Não haverá muito problema removê-lo da análise pois ele não possui código IBGE e, portanto, não haverá match com o shapefile.

```{r}
df_prefeitos_ibge <- df_prefeitos |>
  left_join(df_ibge_tse, by = join_by(id_municipio_tse)) |>
  filter(!is.na(id_municipio)) |>
  left_join(afinidade, by = join_by(partido)) |>
  select(NM_MUNICIPIO:id_municipio, label) |>
  ungroup()
```

## Shapefile dos municípios brasileiros

Finalmente, carregamos o shapefile dos municípios brasileiros, usando o pacote [geobr](https://github.com/ipeaGIT/geobr):

```{r}
mun <- read_municipality(code_muni = "all", year = 2022, simplified = T)
glimpse(mun)
```

### Data wrangling do shapefile

Join com o dataframe de prefeitos vencedores:

```{r}
mun_votos <- mun |>
  mutate(code_muni = as.integer(code_muni)) |>
  left_join(df_prefeitos_ibge, by = join_by(code_muni == id_municipio)) |>
  select(code_muni, name_muni, uf, votos_nominais_validos, partido, label)
glimpse(mun_votos)
```

Checar os valores distintos:

```{r}
mun_votos |> 
  distinct(partido) |>
  as.list()
```

Checando nulos:

```{r}
mun_votos |> filter(is.na(label))
```

Plotando

```{r, fig.align='center', fig.width=18}
mapa_cor_label <- c(
  "esquerda_1" = "#b5000f",
  "esquerda_2" = "#fc0c20",
  "esquerda_3" = "#fc5f6c",
  "centro_1" = "#8ACE00",
  "centro_2" = "#13D626",
  "centro_3" = "#18BC4F",
  "direita_1" = "#2C5EF4",
  "direita_2" = "#0C19D1",
  "direita_3" = "#010CA0"
)

mun_votos |>
  filter(!is.na(label)) |>
  ggplot(mapping = aes(fill = label)) +
  geom_sf(color="#FEBF57") +
  labs(title = "Municípios do Brasil por cluster de afinidade política nas votações de primeiro turno para prefeito (2024)") +
  scale_fill_manual(values = mapa_cor_label)
```

Treemap para comparar as áreas de votos válidos:

```{r}
library(networkD3)
library(treemapify)


df_prefeitos_ibge |>
  mutate(
    label = as.character(label),
    campo_politico = str_split_i(label, "_", i = 1)
  ) |>
  group_by(campo_politico, label) |>
  summarise(
    votos = sum(votos_nominais_validos)
  ) |>
  ungroup() |>
  ggplot(mapping = aes(area = votos, fill = label, subgroup = campo_politico, subgroup2 = label)) +
  geom_treemap() +
  geom_treemap_subgroup_border(size = 1) +
  geom_treemap_subgroup_text(place = "middle", colour = "#fff") +
  scale_fill_manual(values = mapa_cor_label)
```

Contabilizando `centro_1` na esquerda e `centro_3` na direita:

```{r}
df_prefeitos_ibge |>
  mutate(
    label = as.character(label),
    campo_politico = if_else(
      label == "centro_1", "esquerda",
      if_else(label == "centro_3", "direita", str_split_i(label, "_", i = 1))
    )
  ) |>
  group_by(campo_politico, label) |>
  summarise(
    votos = sum(votos_nominais_validos)
  ) |>
  ungroup() |>
  ggplot(mapping = aes(area = votos, fill = label, subgroup = campo_politico, subgroup2 = label)) +
  geom_treemap() +
  geom_treemap_subgroup_border(size = 1) +
  geom_treemap_subgroup_text(place = "middle", colour = "#fff") +
  scale_fill_manual(values = mapa_cor_label)
```

Treemap contendo as populações de cada município, utilizando o pacote [censobr](https://github.com/cran/censobr):

```{r}
library(arrow)
library(censobr)
```

